<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Z</title>
  <style>
    /* 基本布局 */
    html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
    #canvas{display:block;width:100vw;height:100vh}

    /* 叠加 UI（可隐藏）*/
    .ui{position:fixed;left:12px;top:12px;color:#fff;backdrop-filter:blur(6px);background:rgba(0,0,0,0.25);padding:8px 12px;border-radius:10px;font-size:13px}
    .ui small{opacity:.8;display:block}
    .credit{position:fixed;right:12px;bottom:12px;color:rgba(255,255,255,0.6);font-size:12px}

    /* 鼠标提示小圈 */
    .cursor-ring{position:fixed;width:24px;height:24px;border-radius:50%;pointer-events:none;mix-blend-mode:screen;transform:translate(-50%,-50%);box-shadow:0 0 18px rgba(255,255,255,0.06),0 0 60px rgba(255,255,255,0.02)}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="ui">
    <strong>Z</strong>
    <small>鼠标移动 — 改变方向，滚轮或 +/- 控制速度，空格暂停/继续</small>
  </div>
  <div class="credit">     </div>

  <div id="ring" class="cursor-ring"></div>

  <script>
    // 获取画布和上下文
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, window.devicePixelRatio || 1);

    // 可调参数（你可以在代码中改）
    const SETTINGS = {
      starCount: 1200,       // 星点数量
      speed: 16,             // 整体前进速度（像素/帧感觉）
      depth: 1200,           // 隧道深度（影响透视）
      fov: 300,              // 视角，值越小透视越夸张
      colorShift: 0.8,       // 彩色带的鲜艳度
      glow: 0.9              // 发光强度
    };

    // 状态
    let width = 0, height = 0, cx = 0, cy = 0;
    let stars = [];
    let running = true;
    let speedMultiplier = 1;
    const ringElem = document.getElementById('ring');

    function resize(){
      DPR = Math.max(1, window.devicePixelRatio || 1);
      width = Math.floor(window.innerWidth);
      height = Math.floor(window.innerHeight);
      cx = width/2; cy = height/2;
      canvas.width = Math.floor(width * DPR);
      canvas.height = Math.floor(height * DPR);
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.setTransform(DPR,0,0,DPR,0,0);

      // 重新初始化星云
      initStars();
    }

    function rand(min, max){return Math.random()*(max-min)+min}

    function initStars(){
      stars = [];
      for(let i=0;i<SETTINGS.starCount;i++){
        // x, y 在 [-1,1] 里均匀分布，但更靠近中心的概率更高
        const r = Math.sqrt(Math.random());
        const angle = rand(0, Math.PI*2);
        const x = Math.cos(angle)*r;
        const y = Math.sin(angle)*r;
        const z = rand(0, SETTINGS.depth);
        const hue = Math.floor(rand(200, 360)); // 以青蓝->紫红为主色调
        stars.push({x,y,z,hue});
      }
    }

    // 主渲染循环
    let last = performance.now();
    function loop(now){
      const dt = Math.min(40, now - last); // 毫秒
      last = now;
      if(running) update(dt/16.66);
      render();
      requestAnimationFrame(loop);
    }

    function update(delta){
      // delta 大致相当于帧倍率（1 = 60fps）
      const move = SETTINGS.speed * speedMultiplier * delta;
      for(let s of stars){
        s.z -= move;
        if(s.z <= 0){
          // 回收到远端
          s.z = SETTINGS.depth + rand(0,40);
          s.x = Math.cos(rand(0,Math.PI*2))*Math.sqrt(Math.random());
          s.y = Math.sin(rand(0,Math.PI*2))*Math.sqrt(Math.random());
          s.hue = Math.floor(rand(200,360));
        }
      }
    }

    function render(){
      // 背景渐变
      ctx.clearRect(0,0,width,height);

      const g = ctx.createLinearGradient(0,0,0,height);
      g.addColorStop(0, 'rgba(6,8,18,1)');
      g.addColorStop(0.5, 'rgba(8,12,30,0.9)');
      g.addColorStop(1, 'rgba(2,2,10,1)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,width,height);

      // 中心亮晕（制造隧道尽头的亮光）
      const rad = Math.max(width,height) * 0.6;
      const hl = ctx.createRadialGradient(cx,cy,0,cx,cy,rad);
      hl.addColorStop(0, `rgba(255,255,255,${0.08 * SETTINGS.glow})`);
      hl.addColorStop(0.5, `rgba(32,60,100,${0.04 * SETTINGS.glow})`);
      hl.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = hl;
      ctx.fillRect(0,0,width,height);

      // 画一些旋转带状层（制造彩色漩涡）
      const layers = 5;
      for(let i=0;i<layers;i++){
        ctx.save();
        const t = performance.now()/1000;
        const rot = t*0.06*(i%2?1:-1) + i*0.5;
        ctx.translate(cx,cy);
        ctx.rotate(rot);
        ctx.globalAlpha = 0.08 * (1 - i/layers) * SETTINGS.colorShift;

        const grd = ctx.createLinearGradient(-width,0,width,0);
        const c1 = `hsla(${260 - i*10},100%,60%,0.9)`;
        const c2 = `hsla(${300 + i*15},80%,55%,0.9)`;
        const c3 = `hsla(${180 + i*8},80%,65%,0.6)`;
        grd.addColorStop(0, c1);
        grd.addColorStop(0.5, c2);
        grd.addColorStop(1, c3);

        // 画一个长条纹带
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.ellipse(0, 0, width*1.4, height*(0.12 + i*0.03), 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // 画星点（视差投影）
      for(let s of stars){
        // 3D -> 2D 透视投影
        const perspective = SETTINGS.fov / (SETTINGS.fov + s.z);
        const sx = cx + s.x * width * perspective * 1.6;
        const sy = cy + s.y * height * perspective * 1.6;

        // 大小与明暗
        const size = Math.max(0.4, (1 - s.z / SETTINGS.depth) * 3.5);
        const alpha = Math.min(1, (1 - s.z / SETTINGS.depth) * 1.6) * SETTINGS.glow;

        // 运动拉丝效果（速度越快尾巴越长）
        const tail = Math.min(10, (1 - s.z/SETTINGS.depth) * 18) * (speedMultiplier * 0.6);

        // 创建渐变（从头到尾颜色略变）
        const grad = ctx.createLinearGradient(sx, sy, sx - (s.x*tail*8), sy - (s.y*tail*8));
        grad.addColorStop(0, `hsla(${s.hue},100%,70%,${alpha})`);
        grad.addColorStop(0.6, `hsla(${(s.hue+30)%360},90%,60%,${alpha*0.6})`);
        grad.addColorStop(1, `rgba(0,0,0,0)`);

        ctx.beginPath();
        ctx.fillStyle = grad;
        ctx.ellipse(sx, sy, size*2, size, 0, 0, Math.PI*2);
        ctx.fill();
      }

      // 叠加一个轻微的色散噪点（让画面更有质感）
      const noiseCount = 90;
      ctx.globalAlpha = 0.06;
      for(let i=0;i<noiseCount;i++){
        const nx = Math.random()*width;
        const ny = Math.random()*height;
        const s = Math.random()*1.2;
        ctx.fillStyle = `rgba(255,255,255,${Math.random()*0.08})`;
        ctx.fillRect(nx,ny,s,s);
      }
      ctx.globalAlpha = 1;
    }

    // 交互：鼠标促进视角偏移（轻微）
    let mouseX = cx, mouseY = cy;
    window.addEventListener('mousemove', e=>{
      mouseX = e.clientX; mouseY = e.clientY;
      // 更新环状指针位置
      ringElem.style.left = e.clientX+'px';
      ringElem.style.top = e.clientY+'px';
    });

    // 鼠标滚轮控制速度
    window.addEventListener('wheel', e=>{
      if(e.deltaY < 0) speedMultiplier = Math.min(4, speedMultiplier+0.08);
      else speedMultiplier = Math.max(0.1, speedMultiplier-0.08);
    }, {passive:true});

    // 键盘操作
    window.addEventListener('keydown', e=>{
      if(e.key === ' ') { running = !running; e.preventDefault(); }
      if(e.key === '+' || e.key === '=') speedMultiplier = Math.min(6, speedMultiplier + 0.25);
      if(e.key === '-') speedMultiplier = Math.max(0.1, speedMultiplier - 0.25);
      if(e.key === '0') { speedMultiplier = 1; }
    });

    // 点击隐藏/显示 UI
    document.querySelector('.ui').addEventListener('click', ()=>{
      const ui = document.querySelector('.ui');
      ui.style.display = (ui.style.display === 'none') ? 'block' : 'none';
    });

    // 初始化并开始
    resize();
    window.addEventListener('resize', resize);
    requestAnimationFrame(loop);

    // 小提示：移动星点跟随鼠标制造更立体的视差
    (function parallaxFollow(){
      // 让星点轻微偏移以配合鼠标位置（不改变 z）
      function apply(){
        const dx = (mouseX - cx) / Math.max(1, cx) * 0.02;
        const dy = (mouseY - cy) / Math.max(1, cy) * 0.02;
        for(let s of stars){
          s.x += dx * (1 - s.z / SETTINGS.depth) * 0.08;
          s.y += dy * (1 - s.z / SETTINGS.depth) * 0.08;
        }
        requestAnimationFrame(apply);
      }
      apply();
    })();

    // 说明：这是一个纯前端、单文件（.html）示例。
  </script>
</body>
</html>